"use client";
import React, { useCallback, useEffect, useState } from "react";
import { FieldAppSDK } from "@contentful/app-sdk";
import { useSDK } from "@contentful/react-apps-toolkit";
import { Box, Spinner } from "@contentful/f36-components";
import { DEFAULT_THEME } from "../lib/theme-defaults";
import { Theme, ColorScheme } from "../lib/theme-types";
import {
  validateTheme,
  ValidationIssue,
  parseOklch,
  formatOklch,
} from "../lib/theme-validate";
import { generatePaletteFromBase } from "../lib/color-utils";
import { deriveDarkFromLight } from "../lib/theme-derive";
import { serializeAll } from "../lib/theme-serialize";
import { Collapsible, ThemeLogo } from "../components";

// Corner style presets used in the Shape tab
const CORNER_PRESETS = {
  sharp: "0rem",
  soft: "0.375rem",
  rounded: "0.75rem",
  extraRounded: "1rem",
} as const;

function isTheme(value: unknown): value is Theme {
  if (!value || typeof value !== "object") return false;
  const v = value as Record<string, unknown>;
  return !!(v["logo"] && v["colorScheme"] && v["palette"] && v["typography"] && v["shape"]);
}

function srgbToLinear(c: number): number {
  const cs = c / 255;
  return cs <= 0.04045 ? cs / 12.92 : Math.pow((cs + 0.055) / 1.055, 2.4);
}

function hexToRgb(hex: string): { r: number; g: number; b: number } | null {
  const m = hex.replace(/^#/, "");
  if (m.length === 3) {
    const r = parseInt(m[0] + m[0], 16);
    const g = parseInt(m[1] + m[1], 16);
    const b = parseInt(m[2] + m[2], 16);
    return { r, g, b };
  }
  if (m.length === 6 || m.length === 8) {
    const r = parseInt(m.slice(0, 2), 16);
    const g = parseInt(m.slice(2, 4), 16);
    const b = parseInt(m.slice(4, 6), 16);
    return { r, g, b };
  }
  return null;
}

function parseRgb(input: string): { r: number; g: number; b: number } | null {
  const m = input.match(/^rgba?\(([^)]+)\)$/i);
  if (!m) return null;
  const [r, g, b] = m[1].split(",").map((p) => parseFloat(p.trim()));
  if ([r, g, b].some((n) => Number.isNaN(n))) return null;
  return { r, g, b };
}

function getReadableTextColor(bg: string): string {
  const o = parseOklch(bg);
  if (o) return o.L < 0.6 ? "#ffffff" : "#0b0b0b";
  const hex = bg.startsWith("#") ? hexToRgb(bg) : null;
  const rgb = hex || parseRgb(bg);
  if (rgb) {
    const L =
      0.2126 * srgbToLinear(rgb.r) +
      0.7152 * srgbToLinear(rgb.g) +
      0.0722 * srgbToLinear(rgb.b);
    return L < 0.6 ? "#ffffff" : "#0b0b0b";
  }
  return "#ffffff";
}

// sRGB -> OKLab -> OKLCH conversion based on BjÃ¶rn Ottosson's OKLab reference
function rgbToOklab(
  r: number,
  g: number,
  b: number
): { L: number; a: number; b: number } {
  const R = srgbToLinear(r);
  const G = srgbToLinear(g);
  const B = srgbToLinear(b);
  const l = 0.4122214708 * R + 0.5363325363 * G + 0.0514459929 * B;
  const m = 0.2119034982 * R + 0.6806995451 * G + 0.1073969566 * B;
  const s = 0.0883024619 * R + 0.2817188376 * G + 0.6299787005 * B;
  const l_ = Math.cbrt(l);
  const m_ = Math.cbrt(m);
  const s_ = Math.cbrt(s);
  return {
    L: 0.2104542553 * l_ + 0.793617785 * m_ - 0.0040720468 * s_,
    a: 1.9779984951 * l_ - 2.428592205 * m_ + 0.4505937099 * s_,
    b: 0.0259040371 * l_ + 0.7827717662 * m_ - 0.808675766 * s_,
  };
}

function oklabToLch(
  L: number,
  a: number,
  b: number
): { L: number; C: number; H: number } {
  const C = Math.sqrt(a * a + b * b);
  let H = Math.atan2(b, a) * (180 / Math.PI);
  if (!Number.isFinite(H)) H = 0;
  H = ((H % 360) + 360) % 360;
  return { L, C, H };
}

function toOklchString(input: string): string {
  const o = parseOklch(input);
  if (o) return formatOklch(o.L, o.C, o.H, o.A);
  const hex = input.startsWith("#") ? hexToRgb(input) : null;
  const rgb = hex || parseRgb(input);
  if (rgb) {
    const lab = rgbToOklab(rgb.r, rgb.g, rgb.b);
    const lch = oklabToLch(lab.L, lab.a, lab.b);
    return formatOklch(lch.L, lch.C, lch.H);
  }
  return input; // fallback
}

export default function Field() {
  const sdk = useSDK<FieldAppSDK>();
  const [value, setValue] = useState<Theme | null>(null);
  const [issues, setIssues] = useState<ValidationIssue[]>([]);
  const [busy, setBusy] = useState(true);
  const saveTimer = useRef<number | null>(null);
  const [copied, setCopied] = useState<string | null>(null);
  const [activeTab, setActiveTab] = useState<string>("colors");
  const normalizedOnce = useRef<boolean>(false);
  const lightUploadRef = useRef<HTMLInputElement | null>(null);
  const darkUploadRef = useRef<HTMLInputElement | null>(null);
  const canUpload = false; // CMA path disabled
  const canCreate = Boolean((sdk as any)?.navigator?.openNewAsset);

  // Resolve an asset's HTTPS URL by polling the CMA until the file is processed; publish if needed
  const resolveAssetUrl = useCallback(
    async (assetId: string): Promise<string | null> => {
      try {
        const cma = (sdk as any).cma;
        const locale: string = (sdk.locales?.default as any) || "en-US";
        for (let i = 0; i < 15; i++) {
          const a: any = await cma.asset.get({ assetId });
          const f = a?.fields?.file?.[locale];
          if (f?.url) {
            // ensure published so URL is stable
            try {
              await cma.asset.publish({
                assetId: a.sys.id,
                version: a.sys.version,
              });
            } catch {}
            const raw = String(f.url);
            return raw.startsWith("http") ? raw : `https:${raw}`;
          }
          await new Promise((r) => setTimeout(r, 700));
        }
        return null;
      } catch {
        return null;
      }
    },
    [sdk]
  );

  const uploadLogo = useCallback(
    async (file: File): Promise<string | null> => {
      try {
        const cma = (sdk as any).cma;
        // Ensure a stable Blob payload for CMA
        const ab = await file.arrayBuffer();
        const blob = new Blob([ab], {
          type: file.type || "application/octet-stream",
        });
        const { upload } = await cma.upload.create({ file: blob });
        const locale: string = (sdk.locales?.default as any) || "en-US";
        if (!upload?.sys?.id) return null;
        const asset: any = await cma.asset.create({
          fields: {
            title: { [locale]: file.name },
            file: {
              [locale]: {
                contentType: file.type || "application/octet-stream",
                fileName: file.name,
                uploadFrom: {
                  sys: { type: "Link", linkType: "Upload", id: upload.sys.id },
                },
              },
            },
          },
        });
        await cma.asset.processForAllLocales({ assetId: asset.sys.id });
        let processed = false;
        for (let i = 0; i < 15 && !processed; i++) {
          await new Promise((r) => setTimeout(r, 800));
          const a: any = await cma.asset.get({ assetId: asset.sys.id });
          const f = a?.fields?.file?.[locale];
          if (f?.url) {
            await cma.asset.publish({
              assetId: a.sys.id,
              version: a.sys.version,
            });
            const url: string = f.url.startsWith("http")
              ? f.url
              : `https:${f.url}`;
            processed = true;
            return url;
          }
        }
        return null;
      } catch (e) {
        console.error("Upload failed", e);
        return null;
      }
    },
    [sdk]
  );

  // Debounced save to field (defined early so effects can reference it)
  const scheduleSave = useCallback(
    (next: ThemeJson) => {
      setValue(next);
      if (saveTimer.current) window.clearTimeout(saveTimer.current);
      saveTimer.current = window.setTimeout(async () => {
        try {
          await sdk.field.setValue(next);
        } catch (e) {
          console.error("Failed to save field", e);
        }
      }, 600) as unknown as number;
    },
    [sdk]
  );

  // Bootstrap: read field value and seed defaults if empty
  useEffect(() => {
    (async () => {
      try {
        const v = sdk.field.getValue();
        if (isThemeJson(v)) {
          setValue(v);
        } else {
          // Seed defaults from installation parameters if provided
          const install = (sdk.parameters.installation || {}) as {
            primaryColor?: string;
            secondaryColor?: string;
            fontFamily?: string;
          };
          
          // Clone the default theme
          const seeded = { ...DEFAULT_THEME };
          
          // Apply installation parameters if provided
          if (install.primaryColor) {
            const colors = generatePaletteFromBase(install.primaryColor);
            seeded.palette.primary = colors;
          }
          
          if (install.secondaryColor) {
            const colors = generatePaletteFromBase(install.secondaryColor);
            seeded.palette.secondary = colors;
          }
          
          if (install.fontFamily) {
            const typography = {
              ...seeded.typography,
              headers: Object.entries(seeded.typography.headers).reduce((acc, [key, value]) => ({
                ...acc,
                [key]: { ...value, fontFamily: install.fontFamily }
              }), {} as typeof seeded.typography.headers),
              subheader: { ...seeded.typography.subheader, fontFamily: install.fontFamily },
              body: { ...seeded.typography.body, fontFamily: install.fontFamily }
            };
            seeded.typography = typography;
          }
          setValue(seeded);
        }
      } finally {
        setBusy(false);
        sdk.window.startAutoResizer();
      }
    })();
  }, [sdk]);

  // Validate whenever value changes
  useEffect(() => {
    if (!value) return;
    setIssues(validateTheme(value));
  }, [value]);

  // One-time normalization: convert non-OKLCH light colors to OKLCH when sync is enabled
  useEffect(() => {
    if (!value || normalizedOnce.current) return;
    if (!value.meta?.syncLightDark) {
      normalizedOnce.current = true;
      return;
    }
    const light = value.colors?.light || {};
    let changed = false;
    const nextLight: Record<string, string> = {};
    for (const [k, v] of Object.entries(light)) {
      if (typeof v !== "string") continue;
      const isOklch = !!parseOklch(v);
      nextLight[k] = isOklch ? v : toOklchString(v);
      if (!isOklch) changed = true;
    }
    if (changed) {
      normalizedOnce.current = true;
      scheduleSave({
        ...value,
        colors: {
          ...value.colors,
          light: nextLight as unknown as ThemeModeColors,
        },
      });
    } else {
      normalizedOnce.current = true;
    }
  }, [value, scheduleSave]);

  const derived = useMemo(
    () => (value ? deriveDarkFromLight(value) : null),
    [value]
  );
  const exports = useMemo(
    () => (derived ? serializeAll(derived) : null),
    [derived]
  );

  const copyText = useCallback(async (label: string, text: string) => {
    try {
      if (navigator?.clipboard?.writeText) {
        await navigator.clipboard.writeText(text);
      }
      setCopied(label);
      window.setTimeout(() => setCopied(null), 1500);
    } catch {
      // ignore
    }
  }, []);

  if (busy || !value) {
    return (
      <Flex
        alignItems="center"
        justifyContent="center"
        style={{ height: "100%" }}
      >
        <Spinner size="large" />
      </Flex>
    );
  }

  return (
    <Box
      padding="spacingL"
      style={{
        width: "100%",
        boxSizing: "border-box",
        paddingRight: 0,
        paddingLeft: 0,
      }}
    >
      <Heading as="h2" style={{ marginBottom: 4 }}>
        Demo Configuration
      </Heading>
      <Text as="p">Configure your demo properties</Text>

      {/* Validation Issues */}
      {issues.length > 0 ? (
        <Box marginTop="spacingM">
          <Note variant="negative">
            <Heading as="h4">Validation</Heading>
            <ul style={{ marginTop: 8 }}>
              {issues.map((i, idx) => (
                <li key={idx}>
                  <Text as="span">
                    <code>{i.path}</code>: {i.message}
                  </Text>
                </li>
              ))}
            </ul>
          </Note>
        </Box>
      ) : (
        <Box marginTop="spacingM">
          <Note variant="positive">
            <Text>All tokens look valid.</Text>
          </Note>
        </Box>
      )}

      <Collapsible header="Logos" description="Upload logos" defaultOpen>
        <ThemeLogo
          variant="light"
          sdk={sdk}
          canCreate
          canUpload
          uploadLogo={uploadLogo}
          resolveAssetUrl={resolveAssetUrl}
          scheduleSave={scheduleSave}
          value={value}
        />
        <MenuDivider style={{ margin: "24px 0" }} />
        <ThemeLogo
          variant="dark"
          sdk={sdk}
          canCreate
          canUpload
          uploadLogo={uploadLogo}
          resolveAssetUrl={resolveAssetUrl}
          scheduleSave={scheduleSave}
          value={value}
        />
      </Collapsible>

      <Collapsible
        header="Colors"
        description="Select a color scheme."
        defaultOpen
      >


      </Collapsible>

      {/* Editor */}

      <Box
        marginTop="spacingL"
        style={{
          display: "grid",
          gridTemplateColumns: "minmax(0,1fr)",
          gap: 12,
        }}
      >
        <Tabs defaultTab={activeTab} onTabChange={(id) => setActiveTab(id)}>
          <Tabs.List>
            <Tabs.Tab panelId="logo">Logo</Tabs.Tab>
            <Tabs.Tab panelId="colors">Colors</Tabs.Tab>
            <Tabs.Tab panelId="typography">Typography</Tabs.Tab>
            <Tabs.Tab panelId="shape">Shape</Tabs.Tab>
            <Tabs.Tab panelId="exports">Exports</Tabs.Tab>
          </Tabs.List>

          {/* Logo Panel */}
          <Tabs.Panel id="logo">
            <Box
              style={{
                background: "#ffffff",
                border: "1px solid #e6e8f0",
                borderRadius: 12,
                padding: 14,
                color: "#1b1f2a",
              }}
            >
              <Heading as="h4">Logo Settings</Heading>
              <div style={{ display: "grid", gap: 16, marginTop: 12 }}>
                {/* Light Logo */}
                <div>
                  <Text as="h5" fontWeight="fontWeightBold">Light Mode Logo</Text>
                  <Box marginTop="spacingS">
                    <div style={{ display: "flex", gap: 8, alignItems: "center" }}>
                      <TextInput
                        value={value.logo.light.url}
                        onChange={(e) => scheduleSave({
                          ...value,
                          logo: {
                            ...value.logo,
                            light: {
                              ...value.logo.light,
                              url: e.target.value
                            }
                          }
                        })}
                        placeholder="Logo URL"
                      />
                      <TextInput
                        type="number"
                        width="60px"
                        value={value.logo.light.width}
                        onChange={(e) => scheduleSave({
                          ...value,
                          logo: {
                            ...value.logo,
                            light: {
                              ...value.logo.light,
                              width: Number(e.target.value)
                            }
                          }
                        })}
                        placeholder="Width"
                      />
                      <TextInput
                        type="number"
                        width="60px"
                        value={value.logo.light.height}
                        onChange={(e) => scheduleSave({
                          ...value,
                          logo: {
                            ...value.logo,
                            light: {
                              ...value.logo.light,
                              height: Number(e.target.value)
                            }
                          }
                        })}
                        placeholder="Height"
                      />
                    </div>
                  </Box>
                </div>

                {/* Dark Logo */}
                <div>
                  <Text as="h5" fontWeight="fontWeightBold">Dark Mode Logo</Text>
                  <Box marginTop="spacingS">
                    <div style={{ display: "flex", gap: 8, alignItems: "center" }}>
                      <TextInput
                        value={value.logo.dark.url}
                        onChange={(e) => scheduleSave({
                          ...value,
                          logo: {
                            ...value.logo,
                            dark: {
                              ...value.logo.dark,
                              url: e.target.value
                            }
                          }
                        })}
                        placeholder="Logo URL"
                      />
                      <TextInput
                        type="number"
                        width="60px"
                        value={value.logo.dark.width}
                        onChange={(e) => scheduleSave({
                          ...value,
                          logo: {
                            ...value.logo,
                            dark: {
                              ...value.logo.dark,
                              width: Number(e.target.value)
                            }
                          }
                        })}
                        placeholder="Width"
                      />
                      <TextInput
                        type="number"
                        width="60px"
                        value={value.logo.dark.height}
                        onChange={(e) => scheduleSave({
                          ...value,
                          logo: {
                            ...value.logo,
                            dark: {
                              ...value.logo.dark,
                              height: Number(e.target.value)
                            }
                          }
                        })}
                        placeholder="Height"
                      />
                    </div>
                  </Box>
                </div>
              </div>
            </Box>
          </Tabs.Panel>

          {/* Colors Panel */}
          <Tabs.Panel id="colors">
            <Box
              style={{
                background: "#ffffff",
                border: "1px solid #e6e8f0",
                borderRadius: 12,
                padding: 14,
                color: "#1b1f2a",
              }}
            >
              <div style={{ display: "grid", gap: 16 }}>
                <div>
                  <Text as="h5" fontWeight="fontWeightBold">Color Scheme</Text>
                  <Select
                    value={value.colorScheme}
                    onChange={(e) => scheduleSave({
                      ...value,
                      colorScheme: e.target.value as ColorScheme
                    })}
                  >
                    {Object.values(ColorScheme).map((scheme) => (
                      <Select.Option key={scheme} value={scheme}>
                        {scheme}
                      </Select.Option>
                    ))}
                  </Select>
                </div>

                <div>
                  <Heading as="h4" style={{ marginBottom: 12 }}>
                    Primary Palette
                  </Heading>
                  <div style={{ display: "grid", gap: 8 }}>
                    {Object.entries(value.palette.primary).map(([shade, color]) => (
                      <div key={shade} style={{ display: "flex", gap: 8, alignItems: "center" }}>
                        <Text>{shade}</Text>
                        <input
                          type="color"
                          value={color.hex}
                          onChange={(e) => {
                            const newColor = generatePaletteFromBase(e.target.value)[shade];
                            scheduleSave({
                              ...value,
                              palette: {
                                ...value.palette,
                                primary: {
                                  ...value.palette.primary,
                                  [shade]: newColor
                                }
                              }
                            });
                          }}
                          style={{ width: 44, height: 28 }}
                        />
                        <code style={{ fontSize: 12 }}>{color.hex}</code>
                      </div>
                    ))}
                  </div>
                </div>

                <div>
                  <div style={{ display: "flex", gap: 8, alignItems: "center" }}>
                    <Heading as="h4" style={{ marginBottom: 12 }}>Secondary Palette</Heading>
                    <Switch
                      isChecked={!!value.palette.secondary}
                      onChange={() => {
                        scheduleSave({
                          ...value,
                          palette: {
                            ...value.palette,
                            secondary: value.palette.secondary ? null : { ...value.palette.primary }
                          }
                        });
                      }}
                    >
                      Enable
                    </Switch>
                  </div>
                  {value.palette.secondary && (
                    <div style={{ display: "grid", gap: 8 }}>
                      {Object.entries(value.palette.secondary).map(([shade, color]) => (
                        <div key={shade} style={{ display: "flex", gap: 8, alignItems: "center" }}>
                          <Text>{shade}</Text>
                          <input
                            type="color"
                            value={color.hex}
                            onChange={(e) => {
                              const newColor = generatePaletteFromBase(e.target.value)[shade];
                              scheduleSave({
                                ...value,
                                palette: {
                                  ...value.palette,
                                  secondary: {
                                    ...value.palette.secondary,
                                    [shade]: newColor
                                  }
                                }
                              });
                            }}
                            style={{ width: 44, height: 28 }}
                          />
                          <code style={{ fontSize: 12 }}>{color.hex}</code>
                        </div>
                      ))}
                    </div>
                  )}
                </div>

                <div>
                  <Heading as="h4" style={{ marginBottom: 12 }}>System Colors</Heading>
                  <div style={{ display: "grid", gap: 8 }}>
                    <div style={{ display: "flex", gap: 8, alignItems: "center" }}>
                      <Text>White</Text>
                      <input
                        type="color"
                        value={value.palette.white.hex}
                        onChange={(e) => scheduleSave({
                          ...value,
                          palette: {
                            ...value.palette,
                            white: generatePaletteFromBase(e.target.value)["400"]
                          }
                        })}
                        style={{ width: 44, height: 28 }}
                      />
                      <code style={{ fontSize: 12 }}>{value.palette.white.hex}</code>
                    </div>
                    <div style={{ display: "flex", gap: 8, alignItems: "center" }}>
                      <Text>Black</Text>
                      <input
                        type="color"
                        value={value.palette.black.hex}
                        onChange={(e) => scheduleSave({
                          ...value,
                          palette: {
                            ...value.palette,
                            black: generatePaletteFromBase(e.target.value)["400"]
                          }
                        })}
                        style={{ width: 44, height: 28 }}
                      />
                      <code style={{ fontSize: 12 }}>{value.palette.black.hex}</code>
                    </div>
                  </div>
                </div>

                <div>
                  <Heading as="h4" style={{ marginBottom: 12 }}>Gray Scale</Heading>
                  <div style={{ display: "grid", gap: 8 }}>
                    {Object.entries(value.palette.gray).map(([shade, color]) => (
                      <div key={shade} style={{ display: "flex", gap: 8, alignItems: "center" }}>
                        <Text>{shade}</Text>
                        <input
                          type="color"
                          value={color.hex}
                          onChange={(e) => scheduleSave({
                            ...value,
                            palette: {
                              ...value.palette,
                              gray: {
                                ...value.palette.gray,
                                [shade]: generatePaletteFromBase(e.target.value)["400"]
                              }
                            }
                          })}
                          style={{ width: 44, height: 28 }}
                        />
                        <code style={{ fontSize: 12 }}>{color.hex}</code>
                      </div>
                    ))}
                  </div>
                </div>
              </div>
            </Box>
          </Tabs.Panel>

              <Heading as="h4" style={{ marginTop: 16 }}>
                Theme Colors
              </Heading>
              <div
                style={{
                  display: "grid",
                  gridTemplateColumns: "repeat(auto-fit, minmax(160px, 1fr))",
                  gap: 10,
                  marginTop: 8,
                }}
              >
                {(["primary", "secondary", "ring", "border"] as const).map(
                  (key) => {
                    const id = `light-${key}`;
                    const c =
                      (value.colors.light as Record<string, string>)[key] ||
                      "#000000";
                    const tc = getReadableTextColor(c);
                    return (
                      <div key={key} style={{ position: "relative" }}>
                        <input
                          id={id}
                          type="color"
                          defaultValue={c}
                          onChange={(e) => {
                            const picked = toOklchString(e.target.value);
                            const next: ThemeJson = {
                              ...value,
                              colors: {
                                ...value.colors,
                                light: { ...value.colors.light, [key]: picked },
                              },
                            };
                            scheduleSave(next);
                          }}
                          style={{
                            position: "absolute",
                            width: 1,
                            height: 1,
                            opacity: 0,
                            pointerEvents: "none",
                          }}
                        />
                        <label
                          htmlFor={id}
                          style={{
                            display: "flex",
                            justifyContent: "space-between",
                            alignItems: "center",
                            cursor: "pointer",
                            padding: "8px 10px",
                            borderRadius: 10,
                            border: "1px solid #262a36",
                            background: c,
                            color: tc,
                            fontWeight: 700,
                          }}
                        >
                          <span>{key[0].toUpperCase() + key.slice(1)}</span>
                          <span style={{ opacity: 0.85 }}>âŸ³</span>
                        </label>
                      </div>
                    );
                  }
                )}
              </div>

              <Heading as="h4" style={{ marginTop: 16 }}>
                Base colors
              </Heading>
              <div
                style={{
                  display: "grid",
                  gridTemplateColumns: "repeat(auto-fit, minmax(160px, 1fr))",
                  gap: 10,
                  marginTop: 8,
                }}
              >
                {(
                  ["background", "foreground", "primary-foreground"] as const
                ).map((key) => {
                  const id = `light-${key}`;
                  const c =
                    (value.colors.light as Record<string, string>)[key] ||
                    "#000000";
                  const tc = getReadableTextColor(c);
                  return (
                    <div key={key} style={{ position: "relative" }}>
                      <input
                        id={id}
                        type="color"
                        defaultValue={c}
                        onChange={(e) => {
                          const picked = toOklchString(e.target.value);
                          const next: ThemeJson = {
                            ...value,
                            colors: {
                              ...value.colors,
                              light: { ...value.colors.light, [key]: picked },
                            },
                          };
                          scheduleSave(next);
                        }}
                        style={{
                          position: "absolute",
                          width: 1,
                          height: 1,
                          opacity: 0,
                          pointerEvents: "none",
                        }}
                      />
                      <label
                        htmlFor={id}
                        style={{
                          display: "flex",
                          justifyContent: "space-between",
                          alignItems: "center",
                          cursor: "pointer",
                          padding: "8px 10px",
                          borderRadius: 10,
                          border: "1px solid #262a36",
                          background: c,
                          color: tc,
                          fontWeight: 700,
                        }}
                      >
                        <span>{key.replace("-", " ")}</span>
                        <span style={{ opacity: 0.85 }}>ðŸ’§</span>
                      </label>
                    </div>
                  );
                })}
              </div>
            </Box>
          </Tabs.Panel>

          {/* Shape Panel */}
          <Tabs.Panel id="shape">
            <Box
              style={{
                background: "#fff",
                border: "1px solid #eee",
                borderRadius: 8,
                padding: 12,
              }}
            >
              <Heading as="h3">Shape</Heading>
              <div
                style={{
                  display: "grid",
                  gridTemplateColumns: "repeat(auto-fit, minmax(220px, 1fr))",
                  gap: 10,
                  marginTop: 8,
                }}
              >
                <div>
                  <Text as="label" htmlFor="corner-style">
                    Corner style
                  </Text>
                  <Select
                    id="corner-style"
                    value={
                      Object.entries(CORNER_PRESETS).find(
                        ([, v]) => v === value.shape.radius
                      )?.[0] || "custom"
                    }
                    onChange={(e: React.ChangeEvent<HTMLSelectElement>) => {
                      const sel = e.target.value as
                        | keyof typeof CORNER_PRESETS
                        | "custom";
                      if (sel === "custom") return;
                      scheduleSave({
                        ...value,
                        shape: { ...value.shape, radius: CORNER_PRESETS[sel] },
                      });
                    }}
                  >
                    <Select.Option value="sharp">Sharp corners</Select.Option>
                    <Select.Option value="soft">Soft corners</Select.Option>
                    <Select.Option value="rounded">
                      Rounded corners
                    </Select.Option>
                    <Select.Option value="extraRounded">
                      Extra rounded
                    </Select.Option>
                    <Select.Option value="custom">Custom</Select.Option>
                  </Select>
                  <HelpText>
                    Pick a preset; choose Custom to specify your own radius.
                  </HelpText>
                </div>
                <div>
                  <Text as="label" htmlFor="radius">
                    Custom radius
                  </Text>
                  <TextInput
                    id="radius"
                    value={value.shape.radius}
                    onChange={(e) =>
                      scheduleSave({
                        ...value,
                        shape: { ...value.shape, radius: e.target.value },
                      })
                    }
                  />
                  <HelpText>
                    Use rem or px. Examples: 0rem, 0.375rem, 6px
                  </HelpText>
                </div>
                <div>
                  <Text as="label" htmlFor="border">
                    Border size
                  </Text>
                  <TextInput
                    id="border"
                    value={value.shape.border}
                    onChange={(e) =>
                      scheduleSave({
                        ...value,
                        shape: { ...value.shape, border: e.target.value },
                      })
                    }
                  />
                  <HelpText>Examples: 1px, 2px</HelpText>
                </div>
              </div>
            </Box>
          </Tabs.Panel>

          {/* Typography Panel */}
          <Tabs.Panel id="type">
            <Box
              style={{
                background: "#fff",
                border: "1px solid #eee",
                borderRadius: 8,
                padding: 12,
              }}
            >
              <Heading as="h3">Typography</Heading>
              <div
                style={{
                  display: "grid",
                  gridTemplateColumns: "repeat(auto-fit, minmax(220px, 1fr))",
                  gap: 10,
                  marginTop: 8,
                }}
              >
                <div>
                  <Text as="label" htmlFor="font-primary">
                    Primary family
                  </Text>
                  <Select
                    id="font-primary"
                    name="font-primary"
                    value={
                      value.typography.fonts?.[0]?.family || FONT_OPTIONS[0]
                    }
                    onChange={(e: React.ChangeEvent<HTMLSelectElement>) => {
                      const fam = e.target.value;
                      const nextFonts = [
                        {
                          family: fam,
                          variants: ["400", "700"],
                          axes: ["wght"],
                        },
                      ];
                      scheduleSave({
                        ...value,
                        typography: { ...value.typography, fonts: nextFonts },
                      });
                    }}
                  >
                    {FONT_OPTIONS.map((f) => (
                      <Select.Option key={f} value={f}>
                        {f}
                      </Select.Option>
                    ))}
                  </Select>
                </div>
                <div>
                  <Text as="label" htmlFor="font-fallbacks">
                    Fallbacks
                  </Text>
                  <Select
                    id="font-fallbacks"
                    name="font-fallbacks"
                    value={
                      value.typography.fallbacks?.[0] || FALLBACK_OPTIONS[0]
                    }
                    onChange={(e: React.ChangeEvent<HTMLSelectElement>) => {
                      scheduleSave({
                        ...value,
                        typography: {
                          ...value.typography,
                          fallbacks: [e.target.value],
                        },
                      });
                    }}
                  >
                    {FALLBACK_OPTIONS.map((f) => (
                      <Select.Option key={f} value={f}>
                        {f}
                      </Select.Option>
                    ))}
                  </Select>
                </div>
              </div>
              <Box marginTop="spacingM">
                <Heading as="h4">Sizes</Heading>
                <div
                  style={{
                    display: "grid",
                    gridTemplateColumns: "repeat(auto-fit, minmax(160px, 1fr))",
                    gap: 10,
                    marginTop: 8,
                  }}
                >
                  {Object.entries(value.typography.sizeScale).map(([k, v]) => (
                    <div key={k}>
                      <Text as="label" htmlFor={`size-${k}`}>
                        {k}
                      </Text>
                      <TextInput
                        id={`size-${k}`}
                        value={v}
                        onChange={(e) => {
                          const next = {
                            ...value.typography.sizeScale,
                            [k]: e.target.value,
                          };
                          scheduleSave({
                            ...value,
                            typography: {
                              ...value.typography,
                              sizeScale: next,
                            },
                          });
                        }}
                      />
                    </div>
                  ))}
                </div>
              </Box>
            </Box>
          </Tabs.Panel>

          {/* Exports Panel */}
          <Tabs.Panel id="exports">
            <Box>
              <Heading as="h3">Exports</Heading>
              <Box marginTop="spacingS">
                <Text as="label">CSS variables</Text>
                <pre
                  style={{
                    whiteSpace: "pre",
                    background: "#0b1020",
                    color: "#e8e8e8",
                    padding: 12,
                    borderRadius: 8,
                    overflow: "auto",
                    maxHeight: 260,
                  }}
                >
                  {exports?.cssVariables || ""}
                </pre>
                <Button
                  size="small"
                  onClick={() =>
                    exports && copyText("CSS variables", exports.cssVariables)
                  }
                >
                  Copy CSS variables {copied === "CSS variables" ? "âœ“" : ""}
                </Button>
              </Box>
              <Box marginTop="spacingM">
                <Text as="label">Tailwind @theme</Text>
                <pre
                  style={{
                    whiteSpace: "pre",
                    background: "#0b1020",
                    color: "#e8e8e8",
                    padding: 12,
                    borderRadius: 8,
                    overflow: "auto",
                    maxHeight: 260,
                  }}
                >
                  {exports?.tailwindTheme || ""}
                </pre>
                <Button
                  size="small"
                  onClick={() =>
                    exports &&
                    copyText("Tailwind @theme", exports.tailwindTheme)
                  }
                >
                  Copy Tailwind @theme {copied === "Tailwind @theme" ? "âœ“" : ""}
                </Button>
              </Box>
              <Box marginTop="spacingM">
                <Text as="label">Derived Theme JSON</Text>
                <pre
                  style={{
                    whiteSpace: "pre",
                    background: "#0b1020",
                    color: "#e8e8e8",
                    padding: 12,
                    borderRadius: 8,
                    overflow: "auto",
                    maxHeight: 260,
                  }}
                >
                  {JSON.stringify(derived, null, 2)}
                </pre>
              </Box>
            </Box>
          </Tabs.Panel>
        </Tabs>
      </Box>
    </Box>
  );
}

// Curated lists used in Typography panel
const FONT_OPTIONS: string[] = [
  "Inter",
  "Roboto",
  "Open Sans",
  "Source Sans Pro",
  "Poppins",
  "Montserrat",
  "Nunito",
  "Lato",
  "Merriweather",
  "System UI",
];

const FALLBACK_OPTIONS: string[] = [
  "ui-sans-serif, system-ui",
  "system-ui, -apple-system, 'Segoe UI', Roboto, Arial, sans-serif",
  "ui-serif, Georgia, Cambria, 'Times New Roman', serif",
  "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', monospace",
];
